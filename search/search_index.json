{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Forge Documentation","text":"<p>Go to Downloads</p> <p>For source code visit github.com/Imcab.</p>"},{"location":"#why-forge","title":"Why Forge?","text":"<p>For Optimization Revolution Greatest Excellence (FORGE) , is an FIRST Robotics Competition perfomance library made by team FRC 3472, focusing on making the robot program easier, better and ensuring perfomance.</p> <p>Forge is an open-source library consisting in 7 implementations going for PID constants, or other profile constants to a plug-and-play Swerve pathfinder! But thats not all, Forge also includes easy simulation implementation to your robot programm, but the strongest feauture of Forge is <code>NetworkTablesUtil</code>, autoPublish values to the NetworkTables, publish any type of data going for simple <code>double</code> to <code>Pose2d</code>,<code>SwerveModuleState[]</code>, <code>Commands</code> that you can run with a button; with this feature, if you can image it you can publish it, also comes with other small utils like flipping poses, math operations, <code>Equals</code>, Forge has it all to make your robot's performance rocket up!</p> <p>Forge includes various features as:</p> <ul> <li> <p>\u2726 Easy setup</p> <p>Install the zip from downloads, create a <code>/lib/Forge</code> folder in <code>src/main/java/</code> and put it into your robot code in <code>lib/Forge</code> and thats all, you have now fully access to all Forge features!</p> </li> <li> <p>\u2726 Documentation</p> <p>All the methods, classes and functionalities are well-documentated!</p> </li> <li> <p>\u2726 Made for AdvantageScope</p> <p>Forge also makes a lot easier interact with Advantage Scope and other Dashboards and also easy for Custom Dashboards!</p> </li> <li> <p>\u2726 Simulation Support</p> <p>Makes simulation too much easiear and makes simulating your code without tools such as <code>AdvantageKit</code> way to easier without having a mess!</p> </li> <li> <p>\u2726 SwerveLib</p> <p><code>PathPlanner</code> Required.  Plug-and-Play pathfinding implementation without having to worry about pose flipping or any aditional set-up. Also has a <code>SwerveWidget</code> class for dashboard use!</p> </li> <li> <p>\u2726 Open Source</p> <p>Forge is fully Open Source under MIT's licence!</p> </li> </ul> <p></p>"},{"location":"#supported-languages","title":"Supported Languages","text":"<p>Forge was made for Java, C++ or other languages are NOT supported.</p>"},{"location":"page1/","title":"Getting Started","text":""},{"location":"page1/#instalation-guide","title":"Instalation guide","text":""},{"location":"page1/#new-projects","title":"New projects","text":"<p>The best way to download Forge if you don't have a project is downloading the empty template:</p> <p></p> <p>Download template</p> <p>This will come with the last forge update and all the setup required to using forge as freely as you wish.</p>"},{"location":"page1/#existing-projects","title":"Existing projects","text":"<p>To download Forge just go to releases and download the lasted vertion of Forge. If you just want to download one of the various Forge features go to individual releases and download the feature you just want.</p> <p>Info</p> <p>Individual feature downloads are supported as long as you store it in the <code>/lib</code> folder or manually change the package directory to your desired one.</p> <p></p> <p>After you download Forge or a Forge individual release, unzip the file then, go to your robot proyect and go to <code>src/main/java/</code>, create a <code>/lib</code> folder and paste <code>src/main/java/lib/HERE</code>, at the end your robot code should see like this: <code>src/main/java/lib/Forge</code></p>"},{"location":"page1/#pathplanner-vendordep","title":"PathPlanner VendorDep","text":"<p>Because SwerveLib depends on pathplanner to function, before starting to use forge, you must install pathplannerLib.</p> <p>For 2025 the easiest way to install it is through WPILib Vendor Dependency Manager in VSCode.</p> <p></p>"},{"location":"page1/#revlib-vendordep","title":"RevLib VendorDep","text":"<p>The REV feature, needs the last REVLIB vendordep, you can install it like pathplanner's vendor.</p> <p>Warning</p> <p>You MUST install PathPlannerLib and RevLib for SwerveLib to work!</p> <p>If the location of the Forge was right and pathplanner and  REVLIB is already installed, you shouldn't get any errors and you can start using Forge features!</p>"},{"location":"page1/#forge-releases","title":"Forge Releases","text":"<p>Download</p> <p>Includes:</p> <ul> <li>NetworkTablesUtil</li> <li>Sim</li> <li>SwerveLib</li> <li>Equals</li> <li>Field</li> <li>Math</li> <li>RobotState</li> <li>REV</li> </ul>"},{"location":"page1/#individual-releases","title":"Individual Releases","text":""},{"location":"page1/#networktablesutil","title":"NetworkTablesUtil","text":"<p>NetworkTablesUtil is a Forge feature, it includes features as:</p> <ul> <li>Elastic support</li> <li>Auto publish data to NetworkTables</li> <li>Listeners</li> <li>Advantage Scope / Dashboards friendly</li> <li>Tunnable numbers through NetworkTables</li> <li>Support on publishing over 30 diferent data types!</li> <li>Retrieve over 30 diferent data types!</li> <li>Special custom made publishers such as swerve, poseEstimator and joysticks</li> <li>New Subsystem type NetworkSubsystem for more easy use and precise control over NetworkTables</li> <li>Auto publishing commands</li> </ul> <p>Go to repo</p>"},{"location":"page1/#sim","title":"Sim","text":"<p>Sim is a Forge feature, it includes features as:</p> <ul> <li>Handle both real implementations and simulation implementations in a single class</li> <li>With the <code>Device</code> feature, only create objects based on current robot reality</li> <li>Advantage Scope / Dashboards friendly</li> <li>Interface to implement to all type of classes</li> </ul> <p>Go to repo</p>"},{"location":"page1/#swervelib","title":"SwerveLib","text":"<p>SwerveLib is a Forge feature, it includes features as:</p> <ul> <li>Perfomance odometer with automatic Field2d widget display</li> <li><code>PoseFinder class</code>, plug and play posefinding class using pathplanner</li> <li>Advantage Scope / Dashboards friendly</li> <li>Easy elastic swerve widget implementation</li> </ul> <p>Warning</p> <p>You MUST install PathPlannerLib for SwerveLib to work!</p> <p>Go to repo</p>"},{"location":"page1/#equals","title":"Equals","text":"<p>Equals is a Forge feature, featuring:</p> <ul> <li>Comparor class for comparing 2 or more data types within the same line!</li> <li>Domains from x value to y to check if a given value b is within tolerance</li> <li>TwoDimensional Spaces from checking if b (2d object having x and y components) is at f and g</li> <li>ThreeDimensional Spaces</li> <li>Epsilon equals for safe and constant comparison</li> </ul> <p>Go to repo</p>"},{"location":"page1/#field","title":"Field","text":"<p>Field is a Forge feature, featuring:</p> <ul> <li>Easy storage of a field object, giving its length and width</li> <li>Dashboard Support</li> <li>Easy <code>PoseFlipper class</code> for flipping blue alliance poses to red ones</li> <li>Alliance util</li> </ul> <p>Go to repo</p>"},{"location":"page1/#math","title":"Math","text":"<p>Math is a Forge feature, featuring:</p> <ul> <li>Smooth double suppliers outputs by a constant kJ</li> <li>BooleanTriggers</li> <li>Single Operations and Operations</li> <li>Angle operations such as coterminal and new atan 3</li> <li>More flexible pid wrapper classes</li> <li>Feedforward</li> <li>PID loops</li> <li>MotionModel (Trapezoidal control)</li> <li>Cascade control (currently supporting only PID loops)</li> </ul> <p>Custom constants for frc:</p> <ul> <li>PID</li> <li>PIDF</li> <li>SimpleFeedforward</li> <li>CompleteFeedForward</li> <li>MotionModel (for trapezoidal controls or motionModels profiles such as MaxMotion, MotionMagic)</li> <li>MotionModelExpo featuring the use of a jerk term</li> </ul> <p>Go to repo</p>"},{"location":"page1/#robotstate","title":"RobotState","text":"<p>Includes an interface called <code>RobotLifeCycle</code> which gives the class the hability to interact with all the modes of the robot:</p> <ul> <li>Teleop init</li> <li>Teleop</li> <li>Teleop exit</li> <li>Auto</li> <li>Auto Exit</li> <li>Auto init</li> <li>Robot disabled</li> </ul> <p>Go to repo</p>"},{"location":"page1/#rev","title":"REV","text":"<p>Forge REV feauture supports setting the use for REVBlinkin more friendly and having all the patterns Rev has. Also has methods to get the current pattern and methods to check if the blinkin has an especified pattern.</p> <p>Additionaly it contains a wrapper class of an <code>SparkMax</code> motor controller for fast and effective usage.</p> <p>Go to repo</p>"},{"location":"page2/","title":"NetworkTablesUtil - Forge","text":""},{"location":"page2/#ntpublisher","title":"NTPublisher","text":"<p><code>NTPublisher</code> is the ultimate publisher through NetworkTables, works similar and better as the traditional <code>SmartDashboard</code> and also has the hability to retreive more data types</p> Features NTPublisher SmartDashboard Publishing normal values \u2705 \u2705 Publishing special values (Pose2d, etc) \u2705 \u274c Over 30 supported data types \u2705 \u274c Retrieve over 30 data types \u2705 \u274c Sendable support \u2705 \u2705 Different data paths \u2705 \u274c"},{"location":"page2/#publishing-values","title":"Publishing values","text":"<p><code>NTPublisher</code> works the same as <code>SmartDashboard</code> with the extra step of you passing the table you want to publish your data, <code>SmartDashboard</code> puts you data in SmartDashboard/YourData but <code>NTPublisher</code> lets you custom your directory for better organization like: MyDirectory/MyData. Also <code>NTPublisher</code> lets you put your data un subfolders as: MyDirectory/MySubFolder/MyData.</p>"},{"location":"page2/#example","title":"Example","text":"<pre><code>    NTPublisher.publish(\"Robot\", \"GyroConnection\", gyro.isConnected());\n</code></pre>"},{"location":"page2/#subfolder-example","title":"SubFolder example","text":"<pre><code>    NTPublisher.publish(\"Robot\", \"Odometry/Pose\", poseEstimator.getEstimatedPose());\n</code></pre>"},{"location":"page2/#retrieving-values","title":"Retrieving values","text":"<p>For retrieving values you just specify the directory and the key where the data is located and provide a default value in case the data is not found</p> <pre><code>    //Gets the gyro connection\n    // and return false in case NTPublisher fails in locating the value\n    boolean connection = NTPublisher.retrieve(\"Robot\", \"GyroConnection\", false); \n</code></pre> <pre><code>    //Returns 0,0,new Rotation2d() for default value in case of failure\n    Pose2d botPose = NTPublisher.retrieve(\"Robot\", \"Odometry/Pose\", Pose2d.kZero);\n</code></pre>"},{"location":"page2/#supported-data-types","title":"Supported Data Types","text":"<p><code>NTPublisher</code> supports:</p> <ul> <li><code>double</code></li> <li><code>double[]</code></li> <li><code>boolean</code></li> <li><code>boolean[]</code></li> <li><code>String</code></li> <li><code>String[]</code></li> <li><code>ChassisSpeeds</code></li> <li><code>ChassisSpeeds[]</code></li> <li><code>Pose2d</code></li> <li><code>Pose2d[]</code></li> <li><code>Pose3d</code></li> <li><code>Pose3d[]</code></li> <li><code>Rotation2d</code></li> <li><code>Rotation2d[]</code></li> <li><code>Rotation3d</code></li> <li><code>Rotation3d[]</code></li> <li><code>Transform2d</code></li> <li><code>Transform2d[]</code></li> <li><code>Transform3d</code></li> <li><code>Transform3d[]</code></li> <li><code>Translation2d</code></li> <li><code>Translation2d[]</code></li> <li><code>Translation3d</code></li> <li><code>Translation3d[]</code></li> <li><code>SwerveModuleState</code></li> <li><code>SwerveModuleState[]</code></li> <li><code>SwerveModulePosition</code></li> <li><code>SwerveModulePosition[]</code></li> <li><code>Color</code></li> <li><code>Sendable</code></li> </ul>"},{"location":"page2/#manual-sendable-update","title":"Manual Sendable Update","text":"<p>For <code>NTPublisher</code> to update the <code>Sendables</code> you must put an extra line in your <code>robot</code> file or in any method that update periodically, you must call the method above</p> <pre><code>    NTPublisher.updateAllSendables();\n</code></pre> <p>This method is already included in the <code>Forge templates</code> and you don't need to do it unless you manually install Forge</p> <p>Note</p> <p>This section is for users that install Forge manually and not through a template!</p>"},{"location":"page2/#networksubsystem","title":"NetworkSubsystem","text":"<p><code>NetworkSubsystem</code> a wrapper class for <code>SubsystemBase</code> comes with various features such as:</p> <ul> <li>AutoPublish values</li> <li>Autopublish commands</li> <li>Own subsystem directory</li> <li>Easy use of <code>NTPublisher</code></li> <li>Display subsystem information</li> </ul>"},{"location":"page2/#extending-networksubsystem","title":"Extending NetworkSubsystem","text":"<p>For using <code>NetworkSubsystem</code> you need to extend it from your subsystem class instead of <code>SubsystemBase</code>, don't worry, <code>NetworkSubsystem</code> already extends <code>SubsystemBase</code> for you to use</p> <pre><code>    public class ExampleSubsystem extends NetworkSubsystem{\n        ...\n    }\n</code></pre> <p>Now, after you extend the <code>NetworkSubsystem</code> class, you must implement some methods and call the constructor of the <code>NetworkSubsystem</code> class which needs an String as the subsystem's directory and a boolen indicating wether to show or now subsystem information</p> <pre><code>    public class ExampleSubsystem extends NetworkSubsystem{\n\n        //Constructor with the NTSubsystem parameters\n        public ExampleSubsystem(){\n            super(\"AwesomeSubsystem\", true); //Always make sure this line is called first\n        }\n\n        //Use this method as the normal \"periodic\" method, DO NOT OVERRIDE the periodic() method\n        //As it handles internal logic and updates\n        @Override\n        public void NetworkPeriodic(){}\n    }\n</code></pre> <p>Failure</p> <p>Don't override the default periodic() method, use NetworkPeriodic() instead!</p>"},{"location":"page2/#using-networksubsystem","title":"Using NetworkSubsystem","text":"<p>Now that you setup your subsystem you can use various features that this class provides!</p>"},{"location":"page2/#autopublish","title":"AutoPublish","text":"<p>If you want to auto publish a method, you can use the <code>@AutoNetworkPublisher</code> annotation, provide a key and your value is publisher automatically!</p> <pre><code>    //This will be published to YourSubsystemKey/Modules/ChassisSpeeds\n    @AutoNetworkPublisher(key = \"Modules/ChassisSpeeds\")\n    public ChassisSpeeds getChassisSpeeds(){\n        return kinematics.toChassisSpeeds(getModuleStates());\n    }\n</code></pre> <p>Note</p> <p>For AutoNetworkPublisher to work, it must be a compatible data type from <code>NTPublisher</code></p>"},{"location":"page2/#publishcommands","title":"PublishCommands","text":"<p>You can publish a Command to dashboards and have a button to trigger the command on the dashboard, just use the annotation <code>@NetworkCommand</code> and pass a desired key!</p> <pre><code>    @NetworkCommand(\"Commands/ResetHeading\")\n    public Command resetHeadingCommand(){\n        return Commands.runOnce(()-&gt; resetHeading(), this);\n    }\n</code></pre>"},{"location":"page2/#publish-and-retrieving-data","title":"Publish and retrieving data","text":"<p><code>NetworkSubsystem</code> already provides you the table for you to publish values with <code>NTPublisher</code></p> <p>Publishing values, Instead of doing:</p> <pre><code>    NTPublisher.publish(\"MySubsystem\", \"Modules/Locations\", getModuleLocations());\n</code></pre> <p>You can just call:</p> <pre><code>    publishOutput(\"Modules/Locations\", getModuleLocations());\n</code></pre> <p>And it will work exactly the same! all data types supported by <code>NTPublisher</code> are supported by <code>NetworkSubsystem</code></p> <p>And for retrieving a value just use:</p> <pre><code>    //False is the default value we want to use in case\n    //The path is not found\n    boolean myValue = getOutput(\"AwesomeValue\", false);\n</code></pre>"},{"location":"page2/#ntlistener","title":"NTListener","text":"<p><code>NTListener&lt;T&gt;</code> is a generic utility class for subscribing to real-time data updates from WPILib's NetworkTables. It enables tracking of value changes on a specific key in a specific table, supporting a wide range of data types including basic primitives, arrays, and WPILib geometry/kinematics classes.</p>"},{"location":"page2/#using-listener","title":"Using Listener","text":"<p>You must use the provided static factory methods to instantiate an NTListener. Each method creates a listener for a specific data type:</p> <p>Primitives</p> <pre><code>    NTListener&lt;Double&gt; ofDouble(String tableName, String key);\n    NTListener&lt;Boolean&gt; ofBoolean(String tableName, String key);\n    NTListener&lt;String&gt; ofString(String tableName, String key);\n</code></pre> <p>GeometryTypes</p> <pre><code>    NTListener&lt;Pose2d&gt; ofPose2d(...);\n    NTListener&lt;Pose3d&gt; ofPose3d(...);\n    NTListener&lt;Translation2d&gt; ofTranslation2d(...);\n    NTListener&lt;Translation3d&gt; ofTranslation3d(...);\n    NTListener&lt;Rotation2d&gt; ofRotation2d(...);\n    NTListener&lt;Rotation3d&gt; ofRotation3d(...);\n    NTListener&lt;Transform2d&gt; ofTransform2d(...);\n    NTListener&lt;Transform3d&gt; ofTransform3d(...);\n</code></pre> <p>Kinematics</p> <pre><code>    NTListener&lt;SwerveModuleState&gt; ofSwerveModuleState(...);\n    NTListener&lt;SwerveModulePosition&gt; ofSwerveModulePosition(...);\n    NTListener&lt;ChassisSpeeds&gt; ofChassisSpeeds(...);\n</code></pre> <p>Color</p> <pre><code>    NTListener&lt;Color&gt; ofColor(...);\n</code></pre> <p>All of the above types also support array-based listeners:</p> <pre><code>    NTListener&lt;double[]&gt; ofDoubleArray(...);\n    NTListener&lt;Pose2d[]&gt; ofPose2dArray(...);\n    //... and so on\n</code></pre> <p>Example of a <code>NTListener</code> creation</p> <pre><code>    NTListener&lt;Pose2d&gt; robotPoseListener = NTListener.ofPose2d(\"Vision\", \"RobotPose\");\n</code></pre> <ul> <li> <p>Initializes a listener on a NetworkTable entry.</p> </li> <li> <p>Subscribes to kValueAll events.</p> </li> <li> <p>Automatically tracks value changes.</p> </li> </ul>"},{"location":"page2/#methods","title":"Methods","text":"<p>boolean <code>hasChanged()</code></p> <pre><code>    if(robotPoseListener.hasChanged()){\n        //Do something if pose changes\n    }\n</code></pre> <p>Returns true if the value has changed since the last call.</p> <p>Resets internal change flag after read.</p> <p>T <code>getValue()</code></p> <pre><code>    if (robotPoseListener.hasChanged()) {\n        Pose2d updatedPose = robotPoseListener.getValue(); //Get the lastest Pose\n    }\n</code></pre> <p>Retrieves the current value from NetworkTables.</p> <p>Uses the appropriate NTPublisher.retrieve method for type safety.</p> <p>Info</p> <p>This listener does not handle custom object serialization\u2014only types supported by NTPublisher.</p> <p>Warning</p> <p>Make sure to register the listener only once per key to avoid duplicates.</p>"},{"location":"page2/#nttunnablenumber","title":"NTTunnableNumber","text":"<p><code>NTTunnableNumber</code> is a utility class designed to simplify the management of tunable numerical values using NetworkTables. It allows for real-time tuning and monitoring of double values from both the robot code and external interfaces like dashboards.</p> <p>Info</p> <p>Be sure to call update() periodically to keep the internal value in sync with NetworkTables.</p> <p>Features include:</p> <ul> <li> <p>Subscribe to and publish double values via NetworkTables</p> </li> <li> <p>Track and modify values in real time</p> </li> <li> <p>Publish only when values change</p> </li> <li> <p>Detect whether a value has changed externally</p> </li> </ul>"},{"location":"page2/#using-tunnable-number","title":"Using Tunnable number","text":"<p>Parameters for creating a <code>NTTunnableNumber</code> are:</p> <p>key: The NetworkTables key for the value</p> <p>defaultValue: The initial value if no value exists in NetworkTables</p>"},{"location":"page2/#example-constructor","title":"Example constructor","text":"<pre><code>    NTTunnableNumber maxSpeed = new NTTunnableNumber(\"Drive/MaxSpeed\", 3.0);\n</code></pre>"},{"location":"page2/#methods_1","title":"Methods","text":"<p><code>update()</code></p> <p>Updates the internal stored value from the latest subscriber value. Must be called periodically (e.g., in subsystem periodic() method).</p> <pre><code>    maxSpeed.update();\n</code></pre> <p><code>get()</code></p> <p>Returns the current value stored locally (after calling update()).</p> <pre><code>    double speed = maxSpeed.get();\n</code></pre> <p><code>set(double value)</code></p> <p>Sets a new value and publishes it to NetworkTables. Only publishes if the value has changed.</p> <pre><code>    maxSpeed.set(4.0);\n</code></pre> <p><code>hasChanged()</code></p> <p>Checks if the value from NetworkTables is different from the last value set via set() or update().</p> <pre><code>    if (maxSpeed.hasChanged()) {\n        System.out.println(\"Value changed externally!\");\n    }\n</code></pre> <p>Example integration:</p> <pre><code>    public class DriveSubsystem extends SubsystemBase {\n\n        private final NTTunnableNumber maxSpeed = new NTTunnableNumber(\"Drive/MaxSpeed\", 3.0);\n\n        @Override\n        public void periodic() {\n            maxSpeed.update();\n            SmartDashboard.putNumber(\"Current Max Speed\", maxSpeed.get());\n        }\n    }\n</code></pre>"},{"location":"page2/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Always call update() before using get() to ensure fresh values</p> </li> <li> <p>Use consistent NetworkTables paths for tuning parameters</p> </li> <li> <p>Group related keys under the same subsystem namespace (e.g., \"Shooter/PID/kP\")</p> </li> </ul>"},{"location":"page2/#ntjoystick","title":"NTJoystick","text":"<p><code>NTJoystick</code> supports for easy logging of joysticks without having advantage kit, it logs all the values of the avis, buttons, povs and special buttons. Currently supports <code>CommandXBoxController</code>, <code>CommandPS4Controller</code>, <code>CommandPS5Controller</code> and you can manually send your joystick values if you don't use the classes from above.</p>"},{"location":"page2/#usage","title":"Usage","text":"<p>This class works with <code>NTPublisher</code> but can also work with <code>SmartDashboard</code>, all you have to do is call the static method <code>NTJoystick.from(yourJoystick)</code> and pass your joystick and thats it!</p> NTPublisherSmartDashboard <pre><code>    public class RobotContainer {\n\n        private final CommandPS5Controller driver = new CommandPS5Controller(0);\n\n        public RobotContainer() {\n\n            NTPublisher.publish(\"NTControllers\", \"Driver1\", NTJoystick.from(driver)); //publish driver joystick\n\n            configureBindings();\n        }\n    } \n</code></pre> <pre><code>    public class RobotContainer {\n\n        private final CommandPS5Controller driver = new CommandPS5Controller(0);\n\n        public RobotContainer() {\n\n            SmartDashboard.putData(\"Driver1\", NTJoystick.from(driver)); //publish driver joystick to SmartDashboard\n\n            configureBindings();\n        }\n    }\n</code></pre>"},{"location":"page2/#ntswerve","title":"NTSwerve","text":"<p>Publishes swerve drive data to NetworkTables.</p> <ul> <li> <p>ChassisSpeeds \u2013 linear &amp; angular robot velocity</p> </li> <li> <p>Rotation2d \u2013 robot orientation</p> </li> <li> <p>SwerveModuleState[] \u2013 states of all swerve modules</p> </li> </ul>"},{"location":"page2/#using-ntswerve","title":"Using NTSwerve","text":"<pre><code>    NTSwerve ntSwerve = new NTSwerve(\"/MySwerve\");\n\n    ntSwerve.sendSwerve(chassisSpeeds, rotation, moduleStates);\n</code></pre> <p>Efficient for visualizing robot motion and module states in real time.</p>"},{"location":"page2/#ntcommand","title":"NTCommand","text":"<p>Extends <code>Command</code> and auto-publishes it to NetworkTables on creation.</p>"},{"location":"page2/#using-ntcommand","title":"Using NTCommand","text":"<pre><code>    public class MyCommand extends NTCommand {\n\n        public MyCommand() {\n            super(\"/MyCommands\", \"DriveCommand\");\n        }\n    }\n</code></pre> <p>Publishes command state (running, finished, etc.) for visualization/debugging.</p>"},{"location":"page2/#ntposeestimator","title":"NTPoseEstimator","text":"<p>Publishes poses from a SwerveDrivePoseEstimator to NetworkTables using multiple slots. (In case of debugging multiple <code>SwerveDrivePoseEstimator</code>).</p>"},{"location":"page2/#using-ntposeestimator","title":"Using NTPoseEstimator","text":"<pre><code>    NTPoseEstimator posePublisher = new NTPoseEstimator(\"/Pose/\", 3);\n    posePublisher.sendEstimator(odometer, 0);\n</code></pre> <p>Each slot stores the robot's estimated pose for modular multi-robot or multi-instance dashboards.</p>"},{"location":"page2/#ntarrayboolean","title":"NTArrayBoolean","text":"<p>Manually publishes boolean arrays to NetworkTables.</p> <pre><code>    NTArrayBoolean boolPub = new NTArrayBoolean(\"MyKey\");\n    boolPub.sendBoolean(new boolean[] { true, false });\n</code></pre>"},{"location":"page2/#ntarraydata","title":"NTArrayData <p>Manually publishes arrays of <code>struct</code>-based data to NetworkTables.</p> <pre><code>    NTArrayData&lt;MyStructType&gt; dataPub = new NTArrayData&lt;&gt;(\"Key\", MyStructType.struct);\n    dataPub.sendData(new MyStructType[] { ... });\n</code></pre>","text":""},{"location":"page2/#ntarraydouble","title":"NTArrayDouble <p>Manually publishes double[] to NetworkTables.</p> <pre><code>    NTArrayDouble doublePub = new NTArrayDouble(\"Key\");\n    doublePub.sendDouble(new double[] { 1.0, 2.0, 3.0 });\n</code></pre>","text":""},{"location":"page2/#ntarraystring","title":"NTArrayString <p>Manually publishes String[] to NetworkTables.</p> <pre><code>    NTArrayString stringPub = new NTArrayString(\"Key\");\n    stringPub.sendString(new String[] { \"hello\", \"world\" });\n</code></pre>","text":""},{"location":"page2/#ntboolean","title":"NTBoolean <p>Manually publishes a single boolean value to NetworkTables.</p> <pre><code>    NTBoolean boolPub = new NTBoolean(\"Key\");\n    boolPub.sendBoolean(true);\n</code></pre>","text":""},{"location":"page2/#ntdata","title":"NTData <p>Manually publishes a single <code>struct</code>-based data object.</p> <pre><code>    NTData&lt;MyStruct&gt; dataPub = new NTData&lt;&gt;(\"Key\", MyStruct.struct);\n    dataPub.sendData(myStructInstance);\n</code></pre>","text":""},{"location":"page2/#ntdouble","title":"NTDouble <p>Manually publishes a single double value to NetworkTables.</p> <pre><code>    NTDouble doublePub = new NTDouble(\"Key\");\n    doublePub.sendDouble(3.14);\n</code></pre>","text":""},{"location":"page2/#ntstring","title":"NTString <p>Manually publishes a single String to NetworkTables.</p> <pre><code>    NTString stringPub = new NTString(\"Key\");\n    stringPub.sendString(\"Hello, world!\");\n</code></pre>","text":""},{"location":"page2/#ntsupplierboolean","title":"NTSupplierBoolean <p>Manually publishes a boolean from a <code>Supplier&lt;Boolean&gt;.</code></p> <pre><code>    NTSupplierBoolean boolPub = new NTSupplierBoolean(\"Key\", () -&gt; myBoolean);\n    boolPub.update();\n</code></pre>","text":""},{"location":"page2/#ntsupplierbooleanarray","title":"NTSupplierBooleanArray <p>Manually publishes a Boolean[] from a <code>Supplier&lt;Boolean[]&gt;.</code></p> <pre><code>    NTSupplierBooleanArray arrayPub = new NTSupplierBooleanArray(\"Key\", () -&gt; myArray);\n    arrayPub.update();\n</code></pre>","text":""},{"location":"page2/#ntsupplierdouble","title":"NTSupplierDouble <p>Manually publishes a double from a <code>Supplier&lt;Double&gt;.</code></p> <pre><code>    NTSupplierDouble doublePub = new NTSupplierDouble(\"Key\", () -&gt; 3.14);\n    doublePub.update();\n</code></pre>","text":""},{"location":"page2/#ntsupplierdoublearray","title":"NTSupplierDoubleArray <p>Manually publishes a double[] from a <code>Supplier&lt;double[]&gt;.</code></p> <pre><code>    NTSupplierDoubleArray arrayPub = new NTSupplierDoubleArray(\"Key\", () -&gt; new double[] {1.0, 2.0});\n    arrayPub.update();\n</code></pre>","text":""},{"location":"page3/","title":"SwerveLib - Forge","text":""},{"location":"page3/#introduction","title":"Introduction","text":"<p>SwerveLib highlights the use of an own background updater pose estimator, easy built-in <code>SwerveWidget</code> and also a <code>poseFinder</code> with pathplanner.</p> <p>Warning</p> <p>You MUST install PathPlannerLib for SwerveLib to work!</p>"},{"location":"page3/#posefinder","title":"PoseFinder","text":"<p>SwerveLib includes a more friendly <code>poseFinder</code> for pathFinding using pathplanner's lib. It also supports parallel Command groups and other methods to use in your code.</p>"},{"location":"page3/#creating-a-posefinder","title":"Creating a PoseFinder","text":"<p>For creating your PoseFinder you must pass a field Object, a <code>PathConstraints</code> and other requirements.</p> <pre><code>    private PoseFinder pathFinder;\n\n     private static final PathConstraints selectedConstraints = new PathConstraints(\n        4.5,\n        4.0,\n        Units.degreesToRadians(540),\n        Units.degreesToRadians(720)\n    );\n\n    public Swerve(){\n\n        //PathPlanner's configuration must be done first!\n        AutoBuilder.configure(\n            this::getEstimatedPosition,\n            this::setPose,\n            this::getChassisSpeeds,\n            this::runVelocity,\n            new PPHolonomicDriveController(\n                translationPPgains,\n                rotationPPgains,\n                0.02),\n            getPathPlannerConfiguration(),\n            ()-&gt; DriverStation.getAlliance().orElse(Alliance.Blue) == Alliance.Red);\n\n\n        pathFinder = new PoseFinder( \n            FieldObject.REEFSCAPE, //This year's field\n            selectedConstraints, //The PathPlannerConstraints\n            this::runVelocity, //Your method to move your swerve with a desired ChassisSpeeds\n            this::getEstimatedPosition, //Your robot pose\n            this::setPose, //Method to set your robot pose\n            0.02, //Update period (you normally want to use this number)\n            this); //Your swerve subsystem\n    }\n</code></pre>"},{"location":"page3/#using-posefinder","title":"Using PoseFinder","text":"<p>The best way to use your <code>PoseFinder</code> if you have it in your subsystem is to return it for it to be accessed in your <code>RobotContainer</code></p> <p>You should have a method like this in your swerve Subsystem.</p> <pre><code>    public PoseFinder getPathFinder(){\n        return pathFinder;\n    }\n</code></pre> <p>Now in the robot container you can access to the pathFinder and to all its method, NOTE: All poses should be in the blue alliance reference, you shouldn't do any kind of flipping, poseFinder mirrors your pose to the Red Alliance automatically</p> <p>Warning</p> <p>All the poses are based on the blue alliance, poseFinder flips the pose if red alliance, like pathplanner flips their paths based on their alliance</p> <pre><code>    private void configureBindings() {\n        //Going to a pose on button pressed (Blue Alliance Reference)\n        driver.cross().whileTrue(chassis.getPathFinder().toPoseCommand(new Pose2d(2.5, 2.5, Rotation2d.kZero)));\n\n    }\n</code></pre> <p><code>PoseFinder</code> has conditional methods, parallel commands and deadline commands for you to use</p> <pre><code>    //Go to pose\n    chassis.getPathFinder().toPoseCommand(new Pose2d(2.5, 2.5, Rotation2d.kZero));\n    //Go to pose 1 or pose 2 based on x condition (supplier)\n    chassis.getPathFinder().toIFPoseCommand(scoringPose, feederPose, ()-&gt; hasPiece);\n    //Go to the neareast Pose based on current robot's pose\n    chassis.getPathFinder().toNearestPoseCommand(pose1,pose2,pose3,pose4);\n</code></pre> <p>All versions of these methods includes a parallel and a deadline version for you to compose commands.</p>"},{"location":"page3/#follow-paths","title":"Follow Paths","text":"<p><code>PoseFinder</code> has the hability to pathfind and then start a PathPlanner Path from pathName, to do this you can use the method <code>toPathPlannerPath</code> and you pass the path's name.</p> <pre><code>    //PathFind and the follow a path\n    chassis.getPathFinder().toPathPlannerPath(\"MyPath\");\n</code></pre> <p>Note</p> <p>This method is currently in beta so do it with precaution and be updated for future changes.</p>"},{"location":"page3/#forgeswervedriveposeestimator","title":"ForgeSwerveDrivePoseEstimator","text":"<p>A wrapper around WPILib\u2019s <code>SwerveDrivePoseEstimator</code> that runs pose estimation in the background, handles disconnected gyros, and optionally visualizes robot poses using Field2d. The benefits of running the estimation in the background is tha the odometer updates in parallel with the code and it does not need to wait for all previos line to update, getting faster and more reliable updates.</p> <p>Warning</p> <p>Only one instance should be created. Running multiple instances will likely lead to incorrect pose estimation.</p>"},{"location":"page3/#usage","title":"Usage","text":"<p>For creating a <code>ForgeSwerveDrivePoseEstimator</code> you need to pass your robot's kinematics, a method to determine if your gyro is connected, your module positions your gyro rotation and a boolean for creating a field2D widget to show on dashboard. Optional: you can set up your custom update period, defaults 0.02 (Robot's default update cycles).</p> <pre><code>    public class Swerve{\n\n        ForgeSwerveDrivePoseEstimator poseEstimator;\n\n        public Swerve(){\n\n            //Creates a new pose estimator\n            poseEstimator = new ForgeSwerveDrivePoseEstimator(\n                kinematics, //Your kinematics\n                ()-&gt; gyroConnection(), //Supplier to determine your gyro connection\n                this::getModulePositions, //Your current SwerveModulePositions\n                this::getnavXRotation, //Your gyro rotation2d\n                true); //True for creating a widget on the dashboard\n        }\n    }\n</code></pre> <p>The usage is pretty similar as a traditional pose Estimator, the difference is that you don't need to call or worry for any update method because the estimator does it by itself, you can still get your robots pose, reset your robots pose and also get the fieldWidget for adding custom objects such as vision targets, or paths.</p> <pre><code>    public Pose2d getEstimatedPosition() {\n        return poseEstimator.getEstimatedPose();\n    }\n\n    public void setPose(Pose2d pose) {\n        poseEstimator.resetPosition(pose);\n    }\n</code></pre>"},{"location":"page3/#swervewidget","title":"SwerveWidget","text":"<p>Forge includes an easy setup for you to use the Elastic's Swerve Custom Widget through the <code>SwerveWidget</code> class</p>"},{"location":"page3/#setting-up-a-swervewidget","title":"Setting up a SwerveWidget","text":"<p>For setting up a swerve widget you must use the <code>SwerveModuleStateSupplier</code> class, which includes an angle and the module speed, both in doubles, you can create a widget using the <code>SwerveWidget</code> class with the method build:</p> <p>First we create our moduleSuppliers, passing an velocity and our module rotation, this method should be done in the constructor!</p> <pre><code>    public Swerve(){\n\n        SwerveModuleStateSupplier[] suppliers = new SwerveModuleStateSupplier[4];\n\n        suppliers[0] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[0].getModuleVelocity(),\n            ()-&gt; modules[0].getModuleRotation().getRadians());\n\n        suppliers[1] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[1].getModuleVelocity(),\n            ()-&gt; modules[1].getModuleRotation().getRadians());\n\n        suppliers[2] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[2].getModuleVelocity(),\n            ()-&gt; modules[2].getModuleRotation().getRadians());\n\n        suppliers[3] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[3].getModuleVelocity(),\n            ()-&gt; modules[3].getModuleRotation().getRadians());\n    }\n</code></pre>"},{"location":"page3/#building","title":"Building","text":"<p>Now we can just use the <code>build</code> method to send it to the dashboard with a key or <code>buildCustomPath</code> to send it to a desired NetworkTables Path, for <code>buildCustomPath</code> to work you must have <code>NetworkTablesUtil</code> installed. Finnally we should pass the robots rotation in the desired unit, must be the same unit as the module angles.</p>"},{"location":"page3/#normal-build-dashboard","title":"Normal Build (Dashboard)","text":"<pre><code>    public Swerve(){\n\n        SwerveModuleStateSupplier[] suppliers = new SwerveModuleStateSupplier[4];\n\n        suppliers[0] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[0].getModuleVelocity(),\n            ()-&gt; modules[0].getModuleRotation().getRadians());\n\n        suppliers[1] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[1].getModuleVelocity(),\n            ()-&gt; modules[1].getModuleRotation().getRadians());\n\n        suppliers[2] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[2].getModuleVelocity(),\n            ()-&gt; modules[2].getModuleRotation().getRadians());\n\n        suppliers[3] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[3].getModuleVelocity(),\n            ()-&gt; modules[3].getModuleRotation().getRadians());\n\n        SwerveWidget.build(\n                \"Elastic/SwerveWidget\", //Your key in \"String\" to show on the SmartDashboard\n                suppliers[0],\n                suppliers[1],\n                suppliers[2],\n                suppliers[3],\n                ()-&gt; getRotation().getRadians() //Your robots rotation\n        );\n    }\n</code></pre>"},{"location":"page3/#custom-build-networktables","title":"Custom Build (NetworkTables)","text":"<pre><code>    public Swerve(){\n\n        SwerveModuleStateSupplier[] suppliers = new SwerveModuleStateSupplier[4];\n\n        suppliers[0] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[0].getModuleVelocity(),\n            ()-&gt; modules[0].getModuleRotation().getRadians());\n\n        suppliers[1] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[1].getModuleVelocity(),\n            ()-&gt; modules[1].getModuleRotation().getRadians());\n\n        suppliers[2] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[2].getModuleVelocity(),\n            ()-&gt; modules[2].getModuleRotation().getRadians());\n\n        suppliers[3] = new SwerveModuleStateSupplier(\n            ()-&gt; modules[3].getModuleVelocity(),\n            ()-&gt; modules[3].getModuleRotation().getRadians());\n\n        SwerveWidget.buildCustomPath(\n            getTableKey(), //Your table key \"String\"\n            \"Elastic/SwerveWidget\", //Your key \"String\"\n            suppliers[0],\n            suppliers[1],\n            suppliers[2],\n            suppliers[3],\n            ()-&gt; getRotation().getRadians() //Your robots rotation\n        );\n    }\n</code></pre>"},{"location":"page4/","title":"RobotState - Forge","text":""},{"location":"page4/#introduction","title":"Introduction","text":"<p>The <code>RobotState</code> class allows for users to interact with the diferent robot modes through an interface <code>RobotLifeCycle</code> without putting their logic directly into de <code>Robot</code> class, currently it supports these robot modes:</p> <ul> <li>teleopInit</li> <li>teleopPeriodic</li> <li>teleopExit</li> <li>autonomousInit</li> <li>autonomousPeriodic</li> <li>disabledInit</li> <li>disabledPeriodic</li> <li>disabledExit</li> <li>autonomousExit</li> </ul>"},{"location":"page4/#using-robotlifecycle","title":"Using RobotLifeCycle","text":""},{"location":"page4/#class","title":"Class","text":"<p>Info</p> <p>If you create your forge Project through new projects, you don't need to manually implement it to your <code>Robot</code> class!</p> <p>To use <code>RobotLifeCycle</code>, first you need to implement it to your class:</p> <pre><code>    //Using the robotLifeCycle\n    public class ExampleClass implements RobotLifeCycle{\n\n        public ExampleClass(){}\n\n    }\n</code></pre>"},{"location":"page4/#methods","title":"Methods","text":"<p>Now that you have <code>RobotLifeCycle</code> in your class, you can now @Override the methods you want to use!</p> <pre><code>    //Using the robotLifeCycle\n    public class ExampleClass implements RobotLifeCycle{\n\n        public ExampleClass(){}\n\n        @Override\n        public void teleopInit(){\n            System.out.println(\"Initializing teleop...\");\n        }\n\n\n        @Override\n        public void teleopPeriodic(){\n            System.out.println(\"Teleop!!!!\");\n        }\n\n}\n</code></pre>"},{"location":"page4/#next-steps","title":"Next Steps","text":""},{"location":"page4/#robot-container","title":"Robot Container","text":"<p>Now for that you implemented your logic, in the <code>Robot Container</code> or in the class you have all your subsystems, you need to create a list of all the subystems that implements the <code>RobotLyfeCycle</code> and returning it here is an example below:</p> <p>Creating the list:</p> <pre><code>    //Creating the list\n    private final List&lt;RobotLifeCycle&gt; lifecycleSubsystems;\n</code></pre> <p>Returning the list:</p> <pre><code>    //Returning the subsystems\n    public List&lt;RobotLifeCycle&gt; getLifeCycle() {\n        return lifecycleSubsystems;\n    }\n</code></pre> <p>An implementation in <code>RobotContainer</code>:</p> <pre><code>    public class RobotContainer {\n\n    //Subsystems that implement RobotLifeCycle\n    private final NetworkSwerve chassis;\n\n    //Subsystems that implement RobotLifeCycle\n    private final ExampleClass exampleClass;\n\n    //Creating the list\n    private final List&lt;RobotLifeCycle&gt; lifecycleSubsystems;\n\n    public RobotContainer() {\n\n        chassis = new NetworkSwerve(SwervePathConstraints.kNormal);\n\n        exampleClass = new ExampleClass();\n\n        lifecycleSubsystems = List.of(RobotState.getInstance(), exampleClass); //Add more subsystems here that implements RobotLifeCycle class\n\n        configureBindings();\n    }\n\n    private void configureBindings() {}\n\n    public Command getAutonomousCommand() {\n        return Commands.print(\"No autonomous command configured\");\n    }\n\n    //Returning the subsystems\n    public List&lt;RobotLifeCycle&gt; getLifeCycle() {\n        return lifecycleSubsystems;\n    }\n}\n</code></pre> <p>Warning</p> <p>You need to implement all of your subsystems and you need yo have the list in <code>RobotContainer</code> for <code>RobotLifeCycle</code> to work!</p>"},{"location":"page4/#robot","title":"Robot","text":"<p>Finally after you get all your setUp in the <code>RobotContainer</code> you must put an additional lines in the <code>Robot</code> file.</p> <p>You can just copy this template:</p> <pre><code>    // Copyright (c) FIRST and other WPILib contributors.\n    // Open Source Software; you can modify and/or share it under the terms of\n    // the WPILib BSD license file in the root directory of this project.\n\n    package frc.robot;\n\n    import edu.wpi.first.wpilibj.TimedRobot;\n    import edu.wpi.first.wpilibj2.command.Command;\n    import edu.wpi.first.wpilibj2.command.CommandScheduler;\n    import lib.Forge.RobotState.RobotLifeCycle;\n\n    public class Robot extends TimedRobot {\n\n    private Command m_autonomousCommand;\n\n    private final RobotContainer m_robotContainer;\n\n    public Robot() {\n\n        m_robotContainer = new RobotContainer();\n\n    }\n\n    @Override\n    public void robotPeriodic() {\n        CommandScheduler.getInstance().run();\n\n    }\n\n    @Override\n    public void disabledInit() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::disabledInit);\n    }\n\n    @Override\n    public void disabledPeriodic() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::disabledPeriodic);\n    }\n\n    @Override\n    public void disabledExit() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::disabledExit);\n    }\n\n    @Override\n    public void autonomousInit() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::autonomousInit);\n        m_autonomousCommand = m_robotContainer.getAutonomousCommand();\n\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.schedule();\n        }\n    }\n\n    @Override\n    public void autonomousPeriodic() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::autonomousPeriodic);\n    }\n\n    @Override\n    public void autonomousExit() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::autonomousExit);\n    }\n\n    @Override\n    public void teleopInit() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::teleopInit);\n        if (m_autonomousCommand != null) {\n            m_autonomousCommand.cancel();\n        }\n    }\n\n    @Override\n    public void teleopPeriodic() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::teleopPeriodic);\n    }\n\n    @Override\n    public void teleopExit() {\n        m_robotContainer.getLifeCycle().forEach(RobotLifeCycle::teleopExit);\n    }\n\n    @Override\n    public void testInit() {\n        CommandScheduler.getInstance().cancelAll();\n    }\n\n    @Override\n    public void testPeriodic() {}\n\n    @Override\n    public void testExit() {}\n    }\n</code></pre>"},{"location":"page5/","title":"Sim - Forge","text":""},{"location":"page5/#introduction","title":"Introduction","text":"<p>Simulation feature in Forge comes with two custom annotations to hande simulation in your robot code</p> <ul> <li><code>@RealDevice</code>: to handle real hardware devices / objects in your code</li> <li><code>@SimulatedDevice</code>: to handle simulated objects in your code</li> </ul> <p>These annotations are used to the code to decide which objects to create based if the robot is in simulation or not</p>"},{"location":"page5/#simulatedsubsystem","title":"SimulatedSubsystem","text":"<p>For this annotations to work you must implement the <code>SimulatedSubsystem</code> interface.</p> <pre><code>    public class SwerveModule implements SimulatedSubsystem{\n        ...\n    }\n</code></pre>"},{"location":"page5/#using-annotations","title":"Using annotations","text":"<p>Now that your class has the <code>SimulatedSubsystem</code> implementation, you can declare your objects and add an one of two annotations if you want:</p> <pre><code>    public class SwerveModule implements SimulatedSubsystem{\n\n        @RealDevice\n        private CANcoder absoluteEncoder;\n\n        @SimulatedDevice\n        private DCMotorSim driveSim =\n            new DCMotorSim(\n            LinearSystemId.createDCMotorSystem(NEOGearbox, 0.025, driveMotorReduction),\n            NEOGearbox);\n    }\n</code></pre>"},{"location":"page5/#handling-the-annotations","title":"Handling the annotations","text":"<p>After you declared your devices, you need to initializate the devices and passing a path for you to see your devices correctly in your constructor</p> <pre><code>    public class SwerveModule implements SimulatedSubsystem{\n\n        @RealDevice\n        private CANcoder absoluteEncoder;\n\n        @SimulatedDevice\n        private DCMotorSim driveSim =\n            new DCMotorSim(\n            LinearSystemId.createDCMotorSystem(NEOGearbox, 0.025, driveMotorReduction),\n            NEOGearbox);\n\n        public SwerveModule(int index){\n\n            //Use real Configuration\n            if (!isInSimulation()) {\n                this.turnPIDGains = new PIDGains(5.0, 0,0);\n                this.drivePIDGains = new PIDGains(0.05, 0, 0);\n                this.driveFFGains = new SimpleFeedForwardGains(0.1, 0.08, 0);\n\n                createSparks(index);\n\n            }else{\n            //Use sim Configuration\n                this.turnPIDGains = new PIDGains(8.0, 0,0);\n                this.drivePIDGains = new PIDGains(0.05, 0, 0);\n                this.driveFFGains = new SimpleFeedForwardGains(0, 0.0789, 0);  \n            }\n\n            drivePID = new PIDControl(drivePIDGains);\n            turnPID = new PIDControl(turnPIDGains);\n\n            turnPID.continuousInput(-Math.PI, Math.PI);\n\n            initializeSubsystemDevices(\"NetworkSwerve/Devices/Modules\"); //Initializate after all your devices\n\n        }\n    }\n</code></pre>"},{"location":"page5/#subsystem-loops","title":"Subsystem Loops","text":"<p>Both, simulated and real devices must have its own loop, <code>SimulatedSubsystems</code> handles this two loops with its own functions, <code>RealDevicesPeriodic</code> and <code>SimulationDevicesPeriodic</code></p> <pre><code>    @Override\n    public void SimulationDevicesPeriodic(){\n\n        this.moduleAngle = new Rotation2d(turnSim.getAngularPositionRad());\n        this.driveVelocity = driveSim.getAngularVelocityRadPerSec();\n\n        driveSim.setInputVoltage(MathUtil.clamp(driveVoltage, -12.0, 12.0));\n        turnSim.setInputVoltage(MathUtil.clamp(turnVoltage, -12.0, 12.0));\n\n        driveSim.update(0.02);\n        turnSim.update(0.02);\n    }\n\n    @Override\n    public void RealDevicesPeriodic(){\n\n        this.moduleAngle = \n        absoluteEncoder.isConnected() ? \n            Rotation2d.fromRotations(absoluteEncoder.getAbsolutePosition().getValueAsDouble() - Offset) : \n            Rotation2d.fromRotations(turnSparkMax.getPosition().withReduction(turnMotorReduction).getRead());\n\n        this.driveVelocity = driveSparkMax.getVelocity().toRadiansPerSecond().getRead();\n\n        driveSparkMax.setVoltage(driveVoltage);\n        turnSparkMax.setVoltage(turnVoltage);\n\n    }\n</code></pre> <p>After you declared your own loops, you must call <code>handleSubsystemRealityLoop</code> to handle your devices in your main loop:</p> <pre><code>    public void periodic(){\n        handleSubsystemRealityLoop(); // Call this method\n\n        if (angleSetpoint != null) {\n            this.turnVoltage = turnPID.calculate(moduleAngle.getRadians()).getOutput();\n\n            if (speedSetpoint != null) {\n                this.driveVoltage = drivePID.calculate(driveVelocity).plus(()-&gt; ffVolts).getOutput();\n            }else{\n                drivePID.reset();\n            }\n        }else{\n            turnPID.reset();\n        }\n    }\n\n    @Override\n    public void SimulationDevicesPeriodic(){\n\n        this.moduleAngle = new Rotation2d(turnSim.getAngularPositionRad());\n        this.driveVelocity = driveSim.getAngularVelocityRadPerSec();\n\n        driveSim.setInputVoltage(MathUtil.clamp(driveVoltage, -12.0, 12.0));\n        turnSim.setInputVoltage(MathUtil.clamp(turnVoltage, -12.0, 12.0));\n\n        driveSim.update(0.02);\n        turnSim.update(0.02);\n    }\n\n    @Override\n    public void RealDevicesPeriodic(){\n\n        this.moduleAngle = \n        absoluteEncoder.isConnected() ? \n            Rotation2d.fromRotations(absoluteEncoder.getAbsolutePosition().getValueAsDouble() - Offset) : \n            Rotation2d.fromRotations(turnSparkMax.getPosition().withReduction(turnMotorReduction).getRead());\n\n        this.driveVelocity = driveSparkMax.getVelocity().toRadiansPerSecond().getRead();\n\n        driveSparkMax.setVoltage(driveVoltage);\n        turnSparkMax.setVoltage(turnVoltage);\n\n    }\n</code></pre>"},{"location":"page5/#isinsimulation","title":"isInSimulation","text":"<p>Implementing this interface adds you <code>isInSimulation</code> a method to check if your robot code is running in simulation</p> <p>Example usage:</p> <pre><code>    //Use real Configuration\n        if (!isInSimulation()) {\n            this.turnPIDGains = new PIDGains(5.0, 0,0);\n            this.drivePIDGains = new PIDGains(0.05, 0, 0);\n            this.driveFFGains = new SimpleFeedForwardGains(0.1, 0.08, 0);\n\n            createSparks(index);\n\n        }else{\n        //Use sim Configuration\n            this.turnPIDGains = new PIDGains(8.0, 0,0);\n            this.drivePIDGains = new PIDGains(0.05, 0, 0);\n            this.driveFFGains = new SimpleFeedForwardGains(0, 0.0789, 0);\n\n\n        }\n</code></pre>"},{"location":"page6/","title":"Field - forge","text":""},{"location":"page6/#introduction","title":"Introduction","text":"<p>Field comes with three classes for you to use:</p> <ul> <li><code>FieldObject</code> allows you creating (length and width)</li> <li><code>Pose2DFlipper</code> for flipping blue alliance poses into red ones based on a <code>FieldObject</code></li> <li><code>AllianceUtil</code> for getting the robot's alliance</li> </ul>"},{"location":"page6/#fieldobject","title":"FieldObject","text":"<p>For creating a new field object you must pass your length and width in the unit in meters</p> <pre><code>    FieldObject field = new FieldObject(Units.inchesToMeters(690.876), Units.inchesToMeters(317));\n</code></pre> <p>Or you can just get the lastest field for its name:</p> <pre><code>    FieldObject field = FieldObject.REEFSCAPE;\n</code></pre>"},{"location":"page6/#pose2dflipper","title":"Pose2DFlipper","text":"<p>You can use this class to flip your poses into the red alliance, passing it your pose and a <code>FieldObject</code> for it to work:</p> <pre><code>    Pose2d myPose = new Pose2d(0.6,2.5, new Rotation2d());\n\n    //Flipping a pose based on the lastest field\n    Pose2d flippedPose = Pose2DFlipper.flip(myPose, FieldObject.REEFSCAPE);\n</code></pre>"},{"location":"page6/#allianceutil","title":"AllianceUtil","text":"<p>You can get alliance info such as <code>isBlue</code>, <code>isRed</code></p> <pre><code>    boolean isBlue = AllianceUtil.isBlue();\n</code></pre>"},{"location":"page7/","title":"Equals -Forge","text":""},{"location":"page7/#introduction","title":"Introduction","text":"<p>The <code>equals</code> package in Forge provides robust utilities to help you determine if a robot or field object is \"in range\" or \"at space\" in both 2D and 3D environments, or comparing two values, objects. It includes helpful spatial classes and domain checking utilities that are super useful for autonomous logic, alignment, and precision checking.</p>"},{"location":"page7/#conditional","title":"Conditional","text":"<p><code>Conditional</code> provides a set of flexible methods for choosing between values based on boolean conditions or predicates. This utility is helpful when making clean, concise decisions without repetitive <code>if</code>-<code>else</code> blocks.</p> <p>It supports choosing:</p> <ul> <li> <p>Between two objects</p> </li> <li> <p>Between two primitives</p> </li> <li> <p>Among multiple values in a list</p> </li> </ul>"},{"location":"page7/#basic-usage","title":"Basic Usage","text":"<p>You can choose between two values using a condition:</p> <pre><code>    //Examples\n    String winner = Conditional.chooseBetween(\"Blue\", \"Red\", isBlueAlliance);\n\n    double winnerDouble = Conditional.chooseBetween(1.0, 2.0, isBlueAlliance);\n\n    Pose2d winnerPose = Conditional.chooseBetween(myPose1, myPose2, isBlueAlliance);\n</code></pre> <p>Or choose based on a <code>Predicate&lt;T&gt;</code>:</p> <pre><code>    String result = Conditional.chooseBetween(\"Alpha\", \"Beta\", s -&gt; s.startsWith(\"A\"));\n</code></pre>"},{"location":"page7/#choosing-among-a-list","title":"Choosing Among a List","text":"<p>Get an item by index with fallback to the last element:</p> <pre><code>    List&lt;String&gt; strategies = List.of(\"Offense\", \"Defense\", \"Support\");\n    String selected = Conditional.chooseAmong(1, strategies); //\"Defense\"\n</code></pre> <p>Find the first element that matches a predicate:</p> <pre><code>    String startsWithS = Conditional.chooseAmong(strategies, s -&gt; s.startsWith(\"S\"), \"Default\"); //\"Support\"\n</code></pre> <p>Use a boolean array to choose the first matching condition:</p> <pre><code>    boolean[] conditions = new boolean[]{false, true, false};\n    String pick = Conditional.chooseAmong(conditions, strategies, \"Fallback\"); //\"Defense\"\n</code></pre>"},{"location":"page7/#epsilon","title":"Epsilon","text":"<p><code>Epsilon</code> helps you compare floating-point numbers (like <code>double</code>) safely, using a small tolerance value (aka epsilon). This avoids the usual precision issues you get when comparing doubles directly.</p> <p>You can use it to:</p> <ul> <li> <p>Compare two doubles with a custom tolerance</p> </li> <li> <p>Use a default precision <code>(1e-9)</code> for quick checks</p> </li> </ul>"},{"location":"page7/#usage-with-custom-epsilon","title":"Usage (with custom epsilon)","text":"<p>Compares two double values using a custom epsilon:</p> <pre><code>    boolean areEqual = Epsilon.equals(3.14159, 3.14158, 1e-4); //true\n</code></pre> <p>This method returns <code>true</code> if the absolute difference between the values is less than or equal to the epsilon.</p>"},{"location":"page7/#usage-default-epsilon","title":"Usage (default epsilon)","text":"<p>Uses the default kEpsilon value:</p> <pre><code>    boolean isSame = Epsilon.equals(5.000000001, 5.000000002); //true\n</code></pre> <p>Great for when you just want to check if two numbers are \u201cclose enough\u201d without thinking too hard.</p>"},{"location":"page7/#domain","title":"Domain","text":"<p><code>Domain</code> is a class that represents a numerical range. It's useful for checking if values are within certain bounds, how close they are to the edges, and enforcing inclusion or exclusion on range limits.</p> <p>It comes with:</p> <ul> <li> <p>Enum flags for inclusive (<code>FULL</code>) or exclusive (<code>EMPTY</code>) edges</p> </li> <li> <p>Methods for checking if a value is within, at an edge, or outside the range</p> </li> <li> <p>Distance-to-limit calculations</p> </li> </ul>"},{"location":"page7/#creating-a-domain","title":"Creating a Domain","text":"<p>You can create a domain with default full edges:</p> <pre><code>    Domain domain = new Domain(0.0, 10.0);\n</code></pre> <p>Or customize edge inclusivity using <code>DomainEdge</code>:</p> <pre><code>    Domain domain = new Domain(1.0, Domain.DomainEdge.EMPTY, 5.0, Domain.DomainEdge.FULL);\n</code></pre>"},{"location":"page7/#checking-range","title":"Checking Range","text":"<p>You can check if a value is inside, outside, or exactly at the half:</p> <pre><code>    boolean inside = domain.inRange(5.0); //true\n    boolean outside = domain.outOfBounds(11.0); //true\n    boolean halfway = domain.atHalf(5.0); //true\n</code></pre>"},{"location":"page7/#getting-distances","title":"Getting Distances","text":"<p>If you want to know how close a value is to either end:</p> <pre><code>    double toMin = domain.distanceToMin(3.0); //distance to min\n    double toMax = domain.distanceToMax(3.0); //distance to max\n</code></pre>"},{"location":"page7/#min-max-value-access","title":"Min &amp; Max Value Access","text":"<pre><code>    double min = domain.minValue();\n    double max = domain.maxValue();\n</code></pre>"},{"location":"page7/#edge-specific-checks","title":"Edge-Specific Checks","text":"<p>You can also target edge checks directly:</p> <pre><code>    boolean atMin = domain.inMin(0.0);\n    boolean atMax = domain.inMax(10.0);\n</code></pre>"},{"location":"page7/#finding-nearest-edge","title":"Finding Nearest Edge","text":"<pre><code>    Domain.DomainLimit nearest = domain.nearest(8.0); //returns MIN or MAX\n</code></pre>"},{"location":"page7/#domainutils","title":"DomainUtils","text":"<p><code>DomainUtils</code> is a utility class that works alongside <code>Domain</code>, providing quick static methods to work with numeric ranges. It helps you determine if a value is within bounds, out of bounds, or how far it is from a specific limit.</p>"},{"location":"page7/#inrange","title":"inRange","text":"<p>Check if a value lies between two values (inclusive):</p> <pre><code>    boolean inside = DomainUtils.inRange(5.0, 0.0, 10.0); //true\n</code></pre>"},{"location":"page7/#outofrange","title":"outOfRange","text":"<p>Negated version of inRange:</p> <pre><code>    boolean outside = DomainUtils.outOfRange(12.0, 0.0, 10.0); //true\n</code></pre>"},{"location":"page7/#distancetolimit","title":"distanceToLimit","text":"<p>Get the absolute distance between a value and a limit:</p> <pre><code>    double distance = DomainUtils.distanceToLimit(5.0, 10.0); //5.0\n</code></pre> <p>Great for determining proximity to either the min or max boundary.</p>"},{"location":"page7/#twodimensionalspace","title":"TwoDimensionalSpace","text":"<p><code>TwoDimensionalSpace</code> defines a 2D region using a center point and a tolerance percentage. You can use it to determine whether a Pose2d lies within this bounded area.</p>"},{"location":"page7/#constructor","title":"Constructor","text":"<p>Create a space from coordinates</p> <pre><code>    TwoDimensionalSpace space = new TwoDimensionalSpace(2.0, 3.0, 0.1); //10% tolerance\n</code></pre> <p>Create a space from a Translation2d</p> <pre><code>    Translation2d center = new Translation2d(2.0, 3.0);\n    TwoDimensionalSpace space = new TwoDimensionalSpace(center, 0.1);\n</code></pre>"},{"location":"page7/#accessors","title":"Accessors","text":"<p>Get the center as a Translation2d, Get the tolerance used, Get the coordinate ranges.</p> <pre><code>    Translation2d center = space.asTranslation();\n\n    double tol = space.getTolerance();\n\n    Translation2d xRange = space.getXRange(); //xRange.getX() = min, getY() = max\n    Translation2d yRange = space.getYRange();\n</code></pre>"},{"location":"page7/#usage","title":"Usage","text":"<p>Check if a <code>Pose2d</code> is inside the space</p> <pre><code>    boolean inside = space.atSpace(new Pose2d(2.05, 3.05, new Rotation2d()));\n</code></pre>"},{"location":"page7/#threedimensionalspace","title":"ThreeDimensionalSpace","text":"<p><code>ThreeDimensionalSpace</code> defines a bounded 3D region using a center point and a tolerance percentage. It lets you verify whether a <code>Pose3d</code> lies within this 3D boundary. This class works exactly the same as <code>TwoDimensionalSpace</code> but supporting 3d poses.</p>"},{"location":"page9/","title":"Math - Forge","text":""},{"location":"page9/#introduction","title":"Introduction","text":"<p><code>Math</code> is a feature designed to enhance robotics control systems, offering smooth double supplier outputs, boolean triggers, and advanced angle operations like coterminal and atan3. It provides flexible PID wrapper classes, feedforward options, and motion control with trapezoidal profiles and cascade control. Specialized constants for PID, PIDF, SimpleFeedforward, CompleteFeedForward, and MotionModel allow for precise control.</p>"},{"location":"page9/#profilegains","title":"ProfileGains","text":"<p>Used for storing different types of profiles, each one with own Sendables for easy showing on dashboard.</p>"},{"location":"page9/#creating-a-gains-object","title":"Creating a gains object","text":"<pre><code>    PIDGains turnPIDGains = new PIDGains(8.0, 0,0);\n    PIDGains drivePIDGains = new PIDGains(0.05, 0, 0);\n    SimpleFeedForwardGains driveFFGains = new SimpleFeedForwardGains(0, 0.0789, 0); \n</code></pre> <p>Info</p> <p>Check for all the supported types!</p>"},{"location":"page9/#publishing","title":"Publishing","text":"<p>If you want to show the stored gains in the dashboard you can just do:</p> <pre><code>    PIDGains turnPIDGains = new PIDGains(8.0, 0,0);\n\n    SmartDashboard.putData(\"MyGains\", turnPIDGains); //Send it to dashboard\n</code></pre> <p>Warning</p> <p>Don't publish the gains in a periodic() or methods that updates constantly, we recommend using the constructor!</p> <p>In addition, this class support creating gains from an array of doubles or transforming the gains into an array object.</p>"},{"location":"page9/#control","title":"Control","text":"<p>The Control class provides different types of controllers (e.g., PID control, motion model control, etc.) to manage control outputs. It also supports chaining operations on control results, allowing more flexible control designs.</p>"},{"location":"page9/#controlresult","title":"ControlResult","text":"<p>All calculate() methods of Controls return an <code>ControlResult</code>, that represents an output of a control system. You can chain various operations such as addition, subtraction, clamping, etc., on the result.</p>"},{"location":"page9/#swerve-module-example","title":"Swerve module Example","text":"<pre><code>    public void periodic(){\n\n        if (angleSetpoint != null) {\n            this.turnVoltage = turnPID.calculate(moduleAngle.getRadians()).getOutput();\n\n            if (speedSetpoint != null) {\n                //Chains a method\n                this.driveVoltage = drivePID.calculate(driveVelocity).plus(()-&gt; ffVolts).getOutput();\n            }else{\n                drivePID.reset();\n            }\n        }else{\n            turnPID.reset();\n        }\n    }\n</code></pre>"},{"location":"page9/#generic-example","title":"Generic example","text":"<pre><code>    ControlResult result = pid.calculate(moduleAngle.getRadians(), 90)\n    .clamp(-10, 10) //Clamp the result to range [-10, 10]\n    .times(2) //Multiply the result by 2\n    .negate(); //Inverts the output\n\n    double finalOutput = result.getOutput(); //Final output after all operations\n</code></pre>"},{"location":"page9/#usage-of-controllers","title":"Usage of Controllers","text":""},{"location":"page9/#creation","title":"Creation","text":"<p>Creating a control is preatty easy, just create it as you created it from wpilib but instead of pasing each gain parameter kP, kI, kD, you can just pass the entire gains:</p> <p>Creating a simple PID:</p> <pre><code>    //The corresponding gains\n    PIDGains turnPIDGains = new PIDGains(5.0, 0,0);    \n\n    //Creating a PID with the given gains\n    PIDControl turnPID = new PIDControl(turnPIDGains);\n</code></pre> <p>Creating a motionModel (Trapezoidal control) with new gains:</p> <pre><code>    //Individual parameters\n    private static final double ANGLE_KP = 5.0;\n    private static final double ANGLE_KD = 0.4;\n    private static final double ANGLE_MAX_VELOCITY = 8.0;\n    private static final double ANGLE_MAX_ACCELERATION = 20.0;   \n\n    //Creating a MotionModel with the new gains\n    MotionModelControl angleController = new MotionModelControl(\n            new MotionModelGains(\n                ANGLE_KP,\n                0,\n                ANGLE_KD,\n                ANGLE_MAX_VELOCITY,\n                ANGLE_MAX_ACCELERATION));\n</code></pre> <p>Cascade control is a custom Forge controller, supporting two PIDLoops for getting a result</p> <pre><code>    private final PIDControl PositionControl = new PIDControl(outerGains);\n    private final PIDControl VelocityControl = new PIDControl(innerGains);\n\n    private final CascadeControl controller = new CascadeControl(PositionControl, VelocityControl);\n</code></pre>"},{"location":"page9/#usage","title":"Usage","text":"<p>For using controller such as pid, trapezoidal control (motionmodel) or others, is just like wpilib classes:</p> <p>Using pid controller</p> <pre><code>    turnPID.calculate(currentRotation.getRadians(), moduleAngle.getRadians()).getOutput();\n</code></pre> <p>For using Feedforward, it is an static method as it is not as complex as other control models, returns a <code>ControlResult</code> based on a given velocity and acceleration:</p> <pre><code>    //The feedforward gains to calculate the output\n    SimpleFeedForwardGains driveFFGains = new SimpleFeedForwardGains(0, 0.0789, 0); \n\n    //Calculate based on a given velocity and acceleration\n    ffVolts = FeedforwardControl.calculate(driveFFGains, velocity, acceleration).getOutput();\n</code></pre> <p>Using a motion model:</p> <pre><code>    double omega =\n                angleController.calculate(\n                        new PositionState(angleSupplier.get().getRadians()),\n                        drive.getRotation().getRadians()\n                ).getOutput();\n</code></pre> <p>For MotionModel to work you need to pass a <code>Trapezoidal.State</code> as setpoint which includes position and velocity values, if you only want to use it for position you can just create a <code>PositionState</code> and pass the desired position as the example above</p> <p>All methods of common controllers have the hability to set Tolerance, continous input, etc. Except for CascadeControl</p> <pre><code>    //Enabling continousInput\n    angleController.continuousInput(-Math.PI, Math.PI);\n\n    //Setting velocity and position tolerance for a MotionModel profile\n    angleController.setTolerance(0.01, 0);\n</code></pre>"},{"location":"page9/#smoothdoublesupplier","title":"SmoothDoubleSupplier","text":"<p>The <code>SmoothDoubleSupplier</code> class provides a way to filter and smooth joystick inputs in FRC (FIRST Robotics Competition) Java programming. It is designed to improve robot control by reducing joystick sensitivity at low values while still allowing full range motion. This is particularly useful for swerve drive, tank drive, elevator control, and other mechanisms that require precise input adjustments.</p> <p>Why Use SmoothDoubleSupplier?</p> <ul> <li> <p>Enhances joystick control by modifying input response.</p> </li> <li> <p>Prevents sudden jerks in movement.</p> </li> <li> <p>Improves precision in mechanisms like arms, elevators, and intakes.</p> </li> <li> <p>Customizable filtering using parameters (kE, kI, kD).</p> </li> </ul> <p>For properly tuning smooth constants, consider:</p> <ul> <li>Exponential Filtering (kE): Applies a power function to smooth inputs</li> <li>Offset (kI): Constant offset</li> <li>Additional Power Component (kD): Includes another power term for finer adjustments</li> </ul> <p>Info</p> <p>You don't always need to use all the constants, with kE you can get a pretty result</p> <p>If kE &gt; 1, small values are further reduced, enhancing low-speed precision.</p> <p>If kE &lt; 1, small values are amplified, making the joystick more responsive.</p>"},{"location":"page9/#smoothing-an-input","title":"Smoothing an input","text":"<p>To smooth an input just call the apply() method to the DoubleSupplier you want:</p> <pre><code>    //Apply smoothing to the Y-axis input\n    SmoothDoubleSupplier.apply(()-&gt; -driver.getLeftY(), 1.5);\n</code></pre>"},{"location":"page9/#operator","title":"Operator","text":"<p>The <code>Operator</code> class provides a collection of mathematical operations as functional interfaces. It is designed to simplify common mathematical computations in FRC, particularly for joystick input processing, robot movement calculations, and general mathematical utilities.</p> <ul> <li> <p>Binary operations (Operation) like addition, subtraction, and power functions.</p> </li> <li> <p>Unary operations (UnaryOperation) like negation, absolute value, and squaring.</p> </li> <li> <p>Custom mathematical utilities for handling angles and deadbanding joystick input.</p> </li> </ul>"},{"location":"page9/#available-operations","title":"Available operations","text":""},{"location":"page9/#binary-operations-operation","title":"Binary Operations (Operation)","text":"Operation Description <code>ADD</code> Adds two values <code>SUBSTRACT</code> Subtracts second value from first <code>MULTIPLY</code> Multiplies two values <code>DIVIDE</code> Divides first value by second <code>MODULO</code> Remainder of division <code>POWER</code> Raises first value to the power of second <code>DISTANCE</code> Absolute difference between two values <code>MEAN</code> Average of two values <code>DEADBAND</code> Zeroes values below a threshold"},{"location":"page9/#unary-operations-unaryoperation","title":"Unary Operations (UnaryOperation)","text":"Operation Description <code>SQUARE_ROOT</code> Computes square root <code>SQUARE</code> Squares a number <code>NEGATE</code> Negates the value (Inverts) <code>ABSOLUTE</code> Converts to absolute value <code>INVERSE</code> Computes reciprocal <code>INCREMENT</code> Increases value by 1 <code>DECREMENT</code> Decreases value by 1 <code>ROUND</code> Rounds to nearest whole number"},{"location":"page9/#angle-specific-operations","title":"Angle-Specific Operations","text":"Operation Description <code>COTERMINALRADIANS</code> Converts an angle to its coterminal equivalent in radians <code>COTERMINALDEGREES</code> Converts an angle to its coterminal equivalent in degrees <code>MINANGLEDEGREES</code> Finds the smallest angle difference between two degrees values <code>MINANGLERADIANS</code> Finds the smallest angle difference between two radian values"},{"location":"page9/#examples","title":"Examples","text":"<p>Examples of some of the many Operator methods available</p>"},{"location":"page9/#deadbanding-joystick-input","title":"Deadbanding Joystick Input","text":"<p>Removes small joystick noise by zeroing inputs below 0.05.</p> <pre><code>    double joystickInput = -driver.getLeftY();  \n    double deadbandedInput = Operator.DEADBAND.apply(joystickInput, 0.05); \n</code></pre>"},{"location":"page9/#joystick-drive-command","title":"Joystick drive Command","text":"<p>Use Operator to square values:</p> <pre><code>    public static Command joystickDrive(\n        Holonomic drive,\n        DoubleSupplier xSupplier,\n        DoubleSupplier ySupplier,\n        DoubleSupplier omegaSupplier){\n    return Commands.run(\n        () -&gt; {\n            // Apply deadband\n            Translation2d linearVelocity = getLinearVelocityFromJoysticks(xSupplier.getAsDouble(), ySupplier.getAsDouble());\n\n            double omega = MathUtil.applyDeadband(omegaSupplier.getAsDouble(), DEADBAND);\n\n            // Square values\n            omega = Math.copySign(Operator.SQUARE.apply(omega), omega);\n\n            ChassisSpeeds speeds =\n                new ChassisSpeeds(\n                    linearVelocity.getX() * drive.getMaxLinearSpeedMetersPerSec(),\n                    linearVelocity.getY() * drive.getMaxLinearSpeedMetersPerSec(),\n                    omega * drive.getMaxAngularSpeedRadPerSec());\n\n            drive.runVelocity(\n              ChassisSpeeds.fromFieldRelativeSpeeds(\n                  speeds,\n                  AllianceUtil.isRed()\n                      ? drive.getRotation().plus(new Rotation2d(Math.PI))\n                      : drive.getRotation()));\n        },\n        drive);\n    }\n</code></pre>"},{"location":"page9/#normalizing-angles","title":"Normalizing Angles","text":"<p>Ensures an angle is within 0 to 360 degrees:</p> <pre><code>    double angle = 450;  \n    double normalizedAngle = Operator.COTERMINALDEGREES.apply(angle);  \n</code></pre>"},{"location":"page9/#using-custom-operations","title":"Using Custom Operations","text":"<p>Custom operations can be applied to joystick inputs, sensor data, or motor outputs.</p> <pre><code>        private final Joystick joystick = new Joystick(0);\n\n        //Custom operation: raises joystick input to the power of 3\n        private final UnaryOperation cubicScaling = (a) -&gt; a * a * a;\n\n        public void teleopPeriodic() {\n            double joystickValue = joystick.getY();\n            double processedValue = cubicScaling.apply(joystickValue);\n        }\n</code></pre>"},{"location":"page9/#hppmathlib","title":"HPPMathLib","text":"<p>The <code>HPPMathLib</code> class provides utility methods for angle calculations in both degrees and radians. It includes functions for computing coterminal angles, finding the minimum angle difference, and a specialized <code>atan3</code> function.</p>"},{"location":"page9/#coterminal","title":"Coterminal","text":"<p>Returns the coterminal angle of angle in degrees, ensuring it is within [0, 360) or [0, 2\u03c0).</p> DegreesRadians <pre><code>    double normalizedAngle = HPPMathLib.coterminalDegrees(450);  \n</code></pre> <pre><code>    double normalizedAngle = HPPMathLib.coterminalRadians(5.0);  \n</code></pre>"},{"location":"page9/#minangle","title":"MinAngle","text":"<p>Finds the minimum angular difference between ang_from and ang_to</p> DegreesRadians <pre><code>    double minAngle = HPPMathLib.MinAngleDegrees(a, b); \n</code></pre> <pre><code>    double minAngle = HPPMathLib.MinAngleRadians(a, b); \n</code></pre>"},{"location":"page9/#atan-3","title":"Atan 3","text":"<p>Computes the arctangent of y/x while considering a threshold to return a default value if the input is too small.</p> DegreesRadians <pre><code>    double result = HPPMathLib.atan3Degrees(a, b, 0.1, 0);  \n</code></pre> <pre><code>    double result = HPPMathLib.atan3Radians(a, b, 0.1, 0);   \n</code></pre>"},{"location":"page9/#booleantrigger","title":"BooleanTrigger","text":"<p>The <code>BooleanTrigger</code> class is used to track and respond to changes in boolean states over time. It is useful in scenarios where you need to detect transitions, such as detecting when a boolean condition becomes true, false, or changes state.</p> <pre><code>    BooleanTrigger trigger = new BooleanTrigger(() -&gt; someBooleanCondition);\n\n    if (trigger.onTrue()) {\n        //Do something when the condition just became true\n    }\n\n    if (trigger.onFalse()) {\n        //Do something when the condition just became false\n    }\n\n    if (trigger.onChange()) {\n        //Do something when the condition changes\n    }\n\n    BooleanTrigger anotherTrigger = new BooleanTrigger(() -&gt; anotherCondition);\n    BooleanTrigger combinedTrigger = trigger.and(anotherTrigger);\n\n    if (combinedTrigger.onTrue()) {\n        //Do something when both conditions are true\n    }\n</code></pre>"},{"location":"page91/","title":"REV - Forge","text":""},{"location":"page91/#getting-started","title":"Getting started","text":"<p>Forge allows users to program a way to much easier the RevBlinkin lev driver based on all the available patterns Rev offers.</p> <p>Forge also haves its own <code>SparkMax</code> wrapper class</p>"},{"location":"page91/#creating-a-revblinkin","title":"Creating a REVBlinkin","text":"<p>To create a REVBlinkin just pass the pwm port on the RoboRIO an thats all!</p> <pre><code>    //Creating a REVBlinkin on PWM port 0\n    public final REVBlinkin blinkin = new REVBlinkin(0);\n</code></pre>"},{"location":"page91/#setting-a-pattern","title":"Setting a pattern","text":"<p>For setting a patter to the REVBlinkin, use the <code>setPattern()</code> method that accept a pattern from REV LED PATTERN TABLES</p> <pre><code>    //Setting a pattern\n    blinkin.setPattern(PatternType.FireLarge);\n</code></pre>"},{"location":"page91/#getting-a-pattern","title":"Getting a pattern","text":"<p>Forge's REVBlinkin class supports the option to get the current pattern of the device as an <code>optional</code>.</p> <p>Checking if the current pattern is Aqua:</p> <pre><code>    //Get leds current pattern \n    Optional&lt;PatternType&gt; pattern = blinkin.getPattern();\n\n    //Compare\n    if (pattern.isPresent() &amp;&amp; pattern.get().equals(PatternType.Aqua)) {\n      System.out.println(\"Hey! I am Aqua\");\n    }\n</code></pre> <p>If you just want to use the <code>getPattern()</code> method to check if the blinkin has an specified patter you can use the <code>hasPattern()</code> method:</p> <pre><code>    //Compare\n    if (blinkin.hasPattern(PatternType.Aqua)) {\n      System.out.println(\"Hey! I am Aqua\");\n    }\n</code></pre>"},{"location":"page91/#forgesparkmax","title":"ForgeSparkMax","text":"<p><code>ForgeSparkMax</code> is a wrapper instance of  rev\u00b4s <code>SparkMax</code>, it includes new methods, easy dashoard support, integrated relative encoder and easy configuration</p>"},{"location":"page91/#configuring-an-forgesparkmax","title":"Configuring an ForgeSparkMax","text":"<p>For full configuration use the <code>flashConfiguration</code> method which accepts an current limit, invertState, idleMode and voltage compensation</p> <pre><code>    //Creation, ForgeSparkMax can assume you're using MotorType.kBrushless\n    ForgeSparkMax driveSparkMax = new ForgeSparkMax(DriveConstants.frontLeft.DrivePort);\n\n    //Full configuration\n    driveSparkMax.flashConfiguration(\n            isDriveMotorInverted, //The boolean to invert the motor\n            IdleMode.kBrake, //Idle mode\n            43, //Current limit\n            true); // True for 12V voltage Compensation\n</code></pre>"},{"location":"page91/#getting-encoder-reads","title":"Getting encoder reads","text":"<p>For getting inner encoder reads you don't need to create a <code>RelativeEncoder</code> class, <code>ForgeSparkMax</code> already includes and configures the encoder, you can access its method and get an <code>EncoderResult</code> which you can add offsets, invert the read, put reductions, convertions or pass it directly to Radians / Degrees or RadiansPerSecond</p> <pre><code>    //Creation, ForgeSparkMax can assume you're using MotorType.kBrushless\n    ForgeSparkMax driveSparkMax = new ForgeSparkMax(DriveConstants.frontLeft.DrivePort);\n    ForgeSparkMax turnSparkMax = new ForgeSparkMax(DriveConstants.frontLeft.TurnPort);\n\n    //Getting drive Velocity in Radians per Second\n    double driveVelocity = driveSparkMax.getVelocity().toRadiansPerSecond().getRead();\n\n    //Getting drive Position in Radians\n    double drivePosition = driveSparkMax.getPosition().toRadians().getRead();\n\n    //Getting Turn position with a reduction\n    Rotation2d moduleAngle = \n    Rotation2d.fromRotations(\n      turnSparkMax.getPosition().withReduction(turnMotorReduction).getRead());\n</code></pre>"},{"location":"page91/#commands","title":"Commands","text":"<p>This motor class include the capability for easy voltage / speeds commands instead of creating a new command.</p> Example OneExample Two <pre><code>  //Returning a Command for easy use outside this class\n  public Command speedMotorCommand(double speed, Subsystem requirements){\n    return m_motor.speedCommand(speed, requirements);\n  } \n</code></pre> <pre><code>  //Returning a Command for easy use outside this class\n  public Command speedMotorCommand(double speed){\n    return m_motor.speedCommand(speed, this); //using this assuming this method is in an subsystem class \n  }  \n</code></pre>"},{"location":"page91/#publish","title":"Publish","text":"<p>You can publish motor info to the Dashboard / Network tables through a <code>Sendable</code></p> SmartDashboardNTPublisher <pre><code>  SmartDashboard.putData(\"DriveSpark\", driveSparkMax); \n</code></pre> <pre><code>  NTPublisher.publish(\"SwerveModule\", \"Motors\", driveSparkMax);  \n</code></pre>"}]}